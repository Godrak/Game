
/*
void Training::Train(string networkFile) {
    if (shapeDescriptors.empty()) {
        cout << "ERROR: no shape descriptors registered for training" << endl;
        return;
    }

    inProgress = true;
    TrainingCase network(vector<unsigned int>{IMAGE_SIDE_SIZE * IMAGE_SIDE_SIZE,
                                              256,
                                              32,
                                              (int) shapeDescriptors.size()});

//    for (int i = 0; i < BATCH_COUNT; ++i) {
//        cout << "generating batch " << i + 1 << " from " << BATCH_COUNT << endl;
//        GenerateData("batch" + to_string(i) + ".data", BATCH_SIZE * 7 / 10.0f, BATCH_SIZE * 3 / 10.0f, false);
//    }

    Training::GenerateData("test.data", 10000, 10000, false);
//    Training::GenerateData("training.data", 120000, 60000, false);
    auto *testData = fann_read_train_from_file("test.data");
    float mse = network.Test(testData);
    float newMse = mse - 0.0001f;

//    while (newMse < mse) {
    for (int i = 0; i < 30; ++i) {
        mse = newMse;
        string name = "data" + to_string(i) + ".data";
//        GenerateData(name, 10000, 10000, false);
        network.LoadData(name);
        network.Train(10000);
        newMse = network.Test(testData);
    }

    network.Save(networkFile);
    inProgress = false;
}
 */
/*
void Training::ManualTraining(string networkFile) {
    using namespace Training;
    TrainingCase network(vector<unsigned int>{IMAGE_SIDE_SIZE * IMAGE_SIDE_SIZE, 512, 64,
                                              (int) shapeDescriptors.size()});
    string dataName = "data.data";
    string prefix;
    string networkName = "network.net";

    int validDataCount;
    int invalidDataCount;
    int epochCount;
    int repetitions;
    float learningRate;
    float learningMomentum;

    while (true) {
        char command;
        cout << "awaiting command" << endl;
        cin >> command;
        switch (command) {
            case 'g':
                cout << "valid:" << endl;
                cin >> validDataCount;
                cout << " invalid:" << endl;
                cin >> invalidDataCount;
                cout << "dataName:" << endl;
                cin >> dataName;

                GenerateData(dataName, validDataCount, invalidDataCount, false);
                cout << "data generated" << endl;
                continue;
            case 'l':
                cout << "load  data, dataName:" << endl;
                cin >> dataName;
                network.LoadData(dataName);
                cout << "data loaded" << endl;
                continue;
            case 'e':
                cout << "epochCount:" << endl;
                cin >> epochCount;
                network.Train(epochCount);
                continue;
            case 's':
                network.Save(networkName);
                cout << "saved" << endl;
                continue;
            case 't': {
                cout << "test, testFileName: " << endl;
                string testFileName;
                cin >> testFileName;
                cout << "RESULT: " << network.Test(testFileName) << endl;
            }
                continue;
            case 'm':
                cout << "learning rate (default 0.7): " << endl;
                cin >> learningRate;
                cout << "learning momentum (default 0): " << endl;
                cin >> learningMomentum;
                network.SetLearningParams(learningRate, learningMomentum);
                continue;
            case 'q':
                network.Save(networkName);
                return;
            case 'c':
                cout << "testFilesPrefix: " << endl;
                cin >> prefix;
                cout << "valid:" << endl;
                cin >> validDataCount;
                cout << " invalid:" << endl;
                cin >> invalidDataCount;
                cout << "epochCount:" << endl;
                cin >> epochCount;
                cout << "repetitions:" << endl;
                cin >> repetitions;
                for (int i = 0; i < repetitions; ++i) {
                    auto t = std::time(nullptr);
                    cout << "time: " << std::asctime(std::localtime(&t)) << endl;
                    cout << "repetition: " << i << " from " << repetitions << endl;
                    dataName = prefix + to_string(i) + ".data";
                    GenerateData(dataName, validDataCount, invalidDataCount, false);
                    network.LoadData(dataName);
                    cout << "data generated" << endl;
                    network.Train(epochCount);
                }
                continue;
            case 'Q':
                return;
            default:
                cout << "invalid command" << endl;
                cout << "g generate" << endl;
                cout << "c complex" << endl;
                cout << "m learning params" << endl;
                cout << "e train" << endl;
                cout << "t test" << endl;
                cout << "s save" << endl;
                cout << "q quit" << endl;
                cout << "Q quit without save" << endl;
                continue;

        }
    }
}
*/


void StructureTraining() {
    using namespace Training;

    vector<unsigned int> layerOne = {100, 200, 300};
    vector<unsigned int> layerTwo = {10, 20, 30};
    vector<float> targetMse = {0.1, 0.07, 0.04, 0.01};

    for (auto mse : targetMse) {
        for (auto layerOneCount : layerOne) {
            for (auto layerTwoCount : layerTwo) {
                TrainingCase trainingCase(vector<unsigned int>{1024, layerOneCount, layerTwoCount, 4});
                auto finalMse = Training::Train(trainingCase, false, mse);
                trainingCase.Save("network" + to_string(layerOneCount) + "_" + to_string(layerTwoCount)
                                 +"_mse:" + to_string(finalMse) + "embedded:"+to_string(ImageAnalyzer::EMBEDDED_SHAPES_ENABLED)
                                  + "composed:" + to_string(ImageAnalyzer::COMPOSED_SHAPES_ENABLED) + ".net");
            }
        }
    }
};
